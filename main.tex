YourProject/
├─ main.tex
├─ references.bib
├─ Sections/
│  └─ intro.tex
├─ Build/                # generated: intermediates
├─ Output/               # generated: final PDFs
├─ BuildSimple.ps1       # pdflatex (single pass)
├─ BuildWithBib.ps1      # pdflatex → bibtex → pdflatex ×2
├─ clean.ps1             # removes Build/ and (optionally) Output/
└─ .vscode/
   └─ settings.json      # LaTeX Workshop recipes/tools (BibTeX) + defaults


-----------------------------------------------------------

VSCode Settings (JSON) 

{
  "latex-workshop.latex.autoBuild.run": "never",
  "latex-workshop.latex.recipe.default": "pdflatex (simple)",
  "latex-workshop.latex.recipes": [
    { "name": "pdflatex (simple)", "tools": ["build-simple"] },
    { "name": "pdflatex (with bibliography — BibTeX)", "tools": ["build-with-bib"] }
  ],
  "latex-workshop.latex.tools": [
    { "name": "build-simple", "command": "powershell", "args": ["-File", "BuildSimple.ps1"] },
    { "name": "build-with-bib", "command": "powershell", "args": ["-File", "BuildWithBib.ps1"] }
  ]
}

-----------------------------------------------------------

BuildSimple.ps1

# Paths
$mainFile  = "main"    # name without extension
$buildDir  = "Build"   # temp/intermediate files
$outputDir = "Output"  # final PDF destination

$ErrorActionPreference = "Stop"

# Ensure directories exist
New-Item -ItemType Directory -Path $buildDir,$outputDir -Force | Out-Null

# Step 1: Run pdflatex (single pass)
Write-Host "`n Running pdflatex (single pass)..."
pdflatex -synctex=1 -interaction=nonstopmode -halt-on-error -file-line-error `
  -output-directory="$buildDir" "$($mainFile).tex"
if ($LASTEXITCODE -ne 0) { throw "pdflatex failed." }

# Step 2: Move final artifacts to Output/
Write-Host "`n Moving final PDF to output directory..."
Move-Item -Force (Join-Path $buildDir "$mainFile.pdf")     (Join-Path $outputDir "$mainFile.pdf")
if (Test-Path (Join-Path $buildDir "$mainFile.synctex.gz")) {
  Move-Item -Force (Join-Path $buildDir "$mainFile.synctex.gz") (Join-Path $outputDir "$mainFile.synctex.gz")
}

# Cleanup any stray folder in Output (mirrors your screenshot)
Remove-Item -Recurse -Force -ErrorAction SilentlyContinue (Join-Path $outputDir "Sections")

Write-Host "`n Finished Compiling Routine !! Check if there are errors in the log above."

-----------------------------------------------------------
# BuildWithBib.ps1  — pdflatex -> bibtex -> pdflatex x2
$mainFile  = "main"
$buildDir  = "Build"
$outputDir = "Output"
$ErrorActionPreference = "Stop"

New-Item -ItemType Directory -Path $buildDir,$outputDir -Force | Out-Null

Write-Host "`nRunning pdflatex (first pass)..."
pdflatex -synctex=1 -interaction=nonstopmode -halt-on-error -file-line-error `
  -output-directory="$buildDir" "$($mainFile).tex"
if ($LASTEXITCODE -ne 0) { throw "pdflatex (first pass) failed." }

Write-Host "`nRunning bibtex on Build/main..."
bibtex (Join-Path $buildDir $mainFile)
if ($LASTEXITCODE -ne 0) { throw "bibtex failed. See Build\${mainFile}.blg" }

Write-Host "`nRunning pdflatex (second pass)..."
pdflatex -synctex=1 -interaction=nonstopmode -halt-on-error -file-line-error `
  -output-directory="$buildDir" "$($mainFile).tex" | Out-Null

Write-Host "`nRunning pdflatex (third pass)..."
pdflatex -synctex=1 -interaction=nonstopmode -halt-on-error -file-line-error `
  -output-directory="$buildDir" "$($mainFile).tex"

Write-Host "`nMoving final PDF to Output/..."
Move-Item -Force (Join-Path $buildDir "$mainFile.pdf") (Join-Path $outputDir "$mainFile.pdf")
if (Test-Path (Join-Path $buildDir "$mainFile.synctex.gz")) {
  Move-Item -Force (Join-Path $buildDir "$mainFile.synctex.gz") (Join-Path $outputDir "$mainFile.synctex.gz")
}
Remove-Item -Recurse -Force -ErrorAction SilentlyContinue (Join-Path $outputDir "Sections")
Write-Host "`nFinished Compiling Routine !!"
-----------------------------------------------------------

CleanBuild.ps1

param(
  [string]$BuildDir = "Build",
  [string]$OutDir   = "Output",

  # Keep PDFs (and .synctex.gz) by default; use -All to wipe everything in Output/
  [switch]$All,

  # Show what would be deleted without actually deleting
  [switch]$DryRun,

  # Recreate empty Build/ and Output/ after cleaning
  [switch]$Recreate
)

$ErrorActionPreference = "Stop"

function Remove-Path {
  param([string]$Path)
  if (Test-Path -LiteralPath $Path) {
    if ($DryRun) {
      Write-Host "[dry-run] Would remove: $Path"
    } else {
      Remove-Item -LiteralPath $Path -Recurse -Force -ErrorAction SilentlyContinue
      Write-Host "Removed: $Path"
    }
  }
}

# 1) Remove the Build/ directory completely (all intermediates live here)
if (Test-Path -LiteralPath $BuildDir) {
  Remove-Path -Path $BuildDir
} else {
  Write-Host "Build directory not found ($BuildDir) — nothing to do there."
}

# 2) Clean the Output/ directory
if (Test-Path -LiteralPath $OutDir) {
  if ($All) {
    # Wipe everything
    Get-ChildItem -LiteralPath $OutDir -Force -Recurse | ForEach-Object {
      if ($DryRun) {
        Write-Host "[dry-run] Would remove: $($_.FullName)"
      } else {
        Remove-Item -LiteralPath $_.FullName -Recurse -Force -ErrorAction SilentlyContinue
      }
    }
    Write-Host "Output cleared (including PDFs)."
  } else {
    # Keep PDFs and .synctex.gz, remove everything else (files + stray subfolders)
    Get-ChildItem -LiteralPath $OutDir -Recurse -Force | ForEach-Object {
      if ($_.PSIsContainer) {
        # remove non-root folders (e.g., Output/Sections)
        if ($_.FullName -ne (Resolve-Path $OutDir)) {
          Remove-Path -Path $_.FullName
        }
      } else {
        $name = $_.Name
        $keep =
          ($name -match '\.pdf$') -or
          ($name -match '\.synctex\.gz$')
        if (-not $keep) {
          if ($DryRun) {
            Write-Host "[dry-run] Would remove: $($_.FullName)"
          } else {
            Remove-Item -LiteralPath $_.FullName -Force -ErrorAction SilentlyContinue
          }
        }
      }
    }
    Write-Host "Output cleaned (PDFs and .synctex.gz preserved)."
  }
} else {
  Write-Host "Output directory not found ($OutDir) — skipping."
}

# 3) Optionally recreate empty directories
if ($Recreate) {
  if ($DryRun) {
    Write-Host "[dry-run] Would recreate: $BuildDir, $OutDir"
  } else {
    New-Item -ItemType Directory -Path $BuildDir,$OutDir -Force | Out-Null
    Write-Host "Recreated: $BuildDir, $OutDir"
  }
}

Write-Host "✔ Clean completed."
-----------------------------------------------------------

main.tex

\documentclass[11pt,a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{geometry}
\geometry{margin=1in}

\usepackage{amsmath,amssymb}
\usepackage[authoryear]{natbib} % <-- BibTeX + natbib

\title{Dummy Build: Spinors on Riemann Surfaces (BibTeX)}
\author{Test Document}
\date{\today}

\begin{document}
\maketitle

On a closed Riemann surface $(\Sigma,g)$, a spin structure can be encoded by a square root $K^{1/2}$ of the canonical bundle $K$, so that spinor fields identify with sections of $S \cong K^{1/2} \oplus K^{-1/2}$. With respect to the complex structure, the geometric Dirac operator $D$ decomposes as $\sqrt{2}\,(\bar\partial + \bar\partial^{\!*})$, interchanging $K^{1/2}$ and $K^{-1/2}$. Its kernel measures holomorphic and anti-holomorphic spinors and is constrained by Riemann–Roch, while its index is determined topologically by the Atiyah–Singer theorem, reflecting how the analysis of $D$ encodes global geometry \citep{atiyah-singer-1968,friedrich-2000}. Classical sources give the correspondence between spin structures and square roots of $K$, count the $2^{2g}$ spin structures on a genus-$g$ surface, and relate harmonic spinors to the complex geometry of $K^{1/2}$ \citep{lawson-michelsohn-1989}.

\bibliographystyle{plainnat} % or abbrvnat / unsrtnat
\bibliography{references}
\end{document}
-----------------------------------------------------------

references.bib

@book{lawson-michelsohn-1989,
  author    = {Lawson, H. Blaine and Michelsohn, Marie-Louise},
  title     = {Spin Geometry},
  year      = {1989},
  publisher = {Princeton University Press},
  address   = {Princeton, NJ}
}

@article{atiyah-singer-1968,
  author  = {Atiyah, Michael F. and Singer, Isadore M.},
  title   = {The Index of Elliptic Operators I},
  journal = {Annals of Mathematics},
  year    = {1968},
  volume  = {87},
  number  = {3},
  pages   = {484--530},
  doi     = {10.2307/1970715}
}

@book{friedrich-2000,
  author    = {Friedrich, Thomas},
  title     = {Dirac Operators in Riemannian Geometry},
  year      = {2000},
  series    = {Graduate Studies in Mathematics},
  volume    = {25},
  publisher = {American Mathematical Society},
  address   = {Providence, RI}
}
