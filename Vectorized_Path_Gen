To create a vectorized version of `single_asset_trajectory` that generates random integer price increments for an array of `EquityAsset` objects, you can use `np.random.randint` with the appropriate shape to handle multiple trajectories simultaneously.

Here's how you can modify the `single_asset_trajectory_vectorized` function to generate random integer increments and create the corresponding usage example:

### Updated Code

```python
import numpy as np
import multiprocessing as mp

# Example definition of the EquityAsset class
class EquityAsset:
    def __init__(self, name, initial_price):
        self.name = name
        self.initial_price = initial_price

    def __repr__(self):
        return f"EquityAsset({self.name}, {self.initial_price})"

# Vectorized single_asset_trajectory function with random integer increments
def single_asset_trajectory_vectorized(initial_prices, N, K, num_steps=100):
    # Generate random integer increments for all initial prices
    increments = np.random.randint(0, K, (N, len(initial_prices), num_steps))
    trajectories = np.cumsum(increments, axis=2)  # Cumulative sum to simulate price paths
    trajectories += initial_prices[:, np.newaxis, np.newaxis]
    return trajectories

# Function to parallelize the generation of trajectories for an array of EquityAsset objects
def generate_all_trajectories(eqAssetsArray, N, K):
    initial_prices = np.array([eqAsset.initial_price for eqAsset in eqAssetsArray])
    with mp.Pool(mp.cpu_count()) as pool:
        # Split initial prices into chunks for parallel processing
        chunks = np.array_split(initial_prices, mp.cpu_count())
        results = pool.starmap(single_asset_trajectory_vectorized, [(chunk, N, K) for chunk in chunks])
    
    # Concatenate results from all processes
    return np.concatenate(results, axis=1)

# Example usage
if __name__ == "__main__":
    # Create an array of EquityAsset objects
    eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

    # Number of trajectories to generate for each EquityAsset
    N = 10
    
    # Maximum random increment
    K = 5

    # Generate trajectories
    all_trajectories = generate_all_trajectories(eqAssetsArray, N, K)

    # Print the results
    for i, eqAsset in enumerate(eqAssetsArray):
        print(f"Trajectories for {eqAsset.name}:")
        for j in range(N):
            print(all_trajectories[j, i])
```

### Explanation

1. **Vectorized `single_asset_trajectory_vectorized` Function**:
   - This function takes an array of initial prices, the number of trajectories (`N`), and the maximum random increment (`K`).
   - `increments = np.random.randint(0, K, (N, len(initial_prices), num_steps))` generates a 3D array of random integers between 0 and `K` for all initial prices and trajectories.
   - `np.cumsum(increments, axis=2)` computes the cumulative sum along the time axis to simulate price paths.
   - `trajectories += initial_prices[:, np.newaxis, np.newaxis]` shifts the trajectories to start at the given initial prices.

2. **Parallel Processing in `generate_all_trajectories`**:
   - Initial prices are split into chunks for parallel processing using `np.array_split`.
   - `multiprocessing.Pool` is used to parallelize the computation of trajectories.
   - `pool.starmap` applies the vectorized function to each chunk of initial prices along with the number of trajectories and the maximum random increment.
   - The results from all processes are concatenated to form the final array of trajectories.

3. **Example Usage**:
   - The example demonstrates how to create an array of `EquityAsset` objects, specify the number of trajectories and the maximum random increment, and then generate and print the trajectories.

### Usage Example

```python
# Create an array of EquityAsset objects
eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

# Number of trajectories to generate for each EquityAsset
N = 10

# Maximum random increment
K = 5

# Generate trajectories
all_trajectories = generate_all_trajectories(eqAssetsArray, N, K)

# Print the results
for i, eqAsset in enumerate(eqAssetsArray):
    print(f"Trajectories for {eqAsset.name}:")
    for j in range(N):
        print(all_trajectories[j, i])
```

This approach uses vectorization to efficiently generate random increments and cumulative sums, and it leverages multiprocessing to parallelize the computation, providing a significant performance improvement over nested loops.
