Certainly! To generate multiple trajectories efficiently, we should modify `generate_all_trajectories` so that it calls `single_asset_trajectory_vectorized` in parallel, dividing the `Y` calls into parallel units of computation. We'll use the `multiprocessing` module to achieve this.

Here's the revised code:

### Revised Code

```python
import numpy as np
import multiprocessing as mp

# Example definition of the EquityAsset class
class EquityAsset:
    def __init__(self, name, initial_price):
        self.name = name
        self.initial_price = initial_price

    def __repr__(self):
        return f"EquityAsset({self.name}, {self.initial_price})"

# Vectorized single_asset_trajectory function with random integer increments
def single_asset_trajectory_vectorized(initial_prices, N, K):
    # Generate random integer increments for all initial prices
    increments = np.random.randint(0, K, (len(initial_prices), N))
    trajectories = np.cumsum(increments, axis=1)  # Cumulative sum to simulate price paths
    trajectories += initial_prices[:, np.newaxis]  # Add initial prices to each trajectory
    return trajectories

# Helper function to generate multiple trajectories in parallel
def generate_trajectories_parallel(initial_prices, N, K, chunk_size):
    num_assets = len(initial_prices)
    num_chunks = (num_assets + chunk_size - 1) // chunk_size  # Calculate the number of chunks
    chunks = np.array_split(initial_prices, num_chunks)  # Split into chunks

    with mp.Pool(mp.cpu_count()) as pool:
        results = pool.starmap(single_asset_trajectory_vectorized, [(chunk, N, K) for chunk in chunks])
    
    # Concatenate results from all processes
    return np.concatenate(results, axis=0)

# Function to generate Y trajectories for each EquityAsset object
def generate_all_trajectories(eqAssetsArray, N, K, Y, chunk_size=100):
    initial_prices = np.array([eqAsset.initial_price for eqAsset in eqAssetsArray])
    
    # Generate Y trajectories for each asset in parallel
    all_trajectories = np.empty((Y, len(eqAssetsArray), N))
    
    for i in range(Y):
        all_trajectories[i] = generate_trajectories_parallel(initial_prices, N, K, chunk_size)
    
    return all_trajectories

# Example usage
if __name__ == "__main__":
    # Create an array of EquityAsset objects
    eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

    # Number of price increments to generate for each EquityAsset
    N = 10
    
    # Maximum random increment
    K = 5

    # Number of trajectories to generate for each EquityAsset
    Y = 10000

    # Generate trajectories
    all_trajectories = generate_all_trajectories(eqAssetsArray, N, K, Y)

    # Print the shape of the results to verify
    print(all_trajectories.shape)  # Should be (Y, M, N)
```

### Explanation

1. **Vectorized `single_asset_trajectory_vectorized` Function**:
   - Generates random integer increments for the given initial prices, computes cumulative sums to simulate price paths, and adds the initial prices to each trajectory.

2. **Helper Function `generate_trajectories_parallel`**:
   - Splits the initial prices into chunks of a specified size (`chunk_size`).
   - Uses `multiprocessing.Pool` to parallelize the generation of trajectories by applying `single_asset_trajectory_vectorized` to each chunk.
   - Concatenates the results from all processes into a single array.

3. **Main Function `generate_all_trajectories`**:
   - Initializes an empty array to store all trajectories.
   - For each trajectory (total `Y` trajectories), calls `generate_trajectories_parallel` to generate the trajectories in parallel.
   - Returns the final array of all trajectories.

### Usage Example

```python
# Create an array of EquityAsset objects
eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

# Number of price increments to generate for each EquityAsset
N = 10

# Maximum random increment
K = 5

# Number of trajectories to generate for each EquityAsset
Y = 10000

# Generate trajectories
all_trajectories = generate_all_trajectories(eqAssetsArray, N, K, Y)

# Print the shape of the results to verify
print(all_trajectories.shape)  # Should be (Y, M, N)
```

This approach splits the computation of trajectories into manageable chunks that are processed in parallel, improving performance and handling large numbers of trajectories efficiently. The chunk size can be adjusted to balance the workload and optimize performance.
