I see, the goal is to split the generation of the trajectories (`Y`) across multiple cores, while keeping the computation for each asset intact. Each core should generate a portion of the total trajectories.

Here's the revised approach:

### Revised Code

```python
import numpy as np
import multiprocessing as mp

# Example definition of the EquityAsset class
class EquityAsset:
    def __init__(self, name, initial_price):
        self.name = name
        self.initial_price = initial_price

    def __repr__(self):
        return f"EquityAsset({self.name}, {self.initial_price})"

# Vectorized single_asset_trajectory function with random integer increments
def single_asset_trajectory_vectorized(initial_prices, N, K, num_trajectories):
    # Generate random integer increments for all initial prices
    increments = np.random.randint(0, K, (num_trajectories, len(initial_prices), N))
    trajectories = np.cumsum(increments, axis=2)  # Cumulative sum to simulate price paths
    trajectories += initial_prices[:, np.newaxis, np.newaxis]  # Add initial prices to each trajectory
    return trajectories

# Function to generate multiple trajectories in parallel
def generate_all_trajectories(eqAssetsArray, N, K, Y):
    initial_prices = np.array([eqAsset.initial_price for eqAsset in eqAssetsArray])
    
    # Determine number of cores
    num_cores = mp.cpu_count()
    
    # Determine number of trajectories per core
    trajectories_per_core = Y // num_cores
    
    # Function to generate trajectories for a chunk of Y
    def generate_chunk(chunk_size):
        return single_asset_trajectory_vectorized(initial_prices, N, K, chunk_size)
    
    # Use multiprocessing to generate trajectories in parallel
    with mp.Pool(num_cores) as pool:
        results = pool.map(generate_chunk, [trajectories_per_core] * num_cores)
    
    # Concatenate results from all processes
    all_trajectories = np.concatenate(results, axis=0)
    
    return all_trajectories

# Example usage
if __name__ == "__main__":
    # Create an array of EquityAsset objects
    eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

    # Number of price increments to generate for each EquityAsset
    N = 10
    
    # Maximum random increment
    K = 5

    # Number of trajectories to generate for each EquityAsset
    Y = 10000

    # Generate trajectories
    all_trajectories = generate_all_trajectories(eqAssetsArray, N, K, Y)

    # Print the shape of the results to verify
    print(all_trajectories.shape)  # Should be (Y, M, N)
```

### Explanation

1. **Vectorized `single_asset_trajectory_vectorized` Function**:
   - Generates random integer increments for the given initial prices and computes cumulative sums to simulate price paths. It adds the initial prices to each trajectory.
   - The additional parameter `num_trajectories` specifies how many trajectories to generate in each call.

2. **Function to Generate Trajectories in Parallel**:
   - `generate_all_trajectories` splits the total number of trajectories (`Y`) across multiple cores (`num_cores`).
   - Each core generates `trajectories_per_core` trajectories.

3. **Multiprocessing Pool**:
   - The `generate_chunk` function is defined to generate a chunk of trajectories.
   - `pool.map` is used to parallelize the generation of these chunks across the available cores.
   - The results from all processes are concatenated along the trajectory axis to form the final array of trajectories.

### Usage Example

```python
# Create an array of EquityAsset objects
eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

# Number of price increments to generate for each EquityAsset
N = 10

# Maximum random increment
K = 5

# Number of trajectories to generate for each EquityAsset
Y = 10000

# Generate trajectories
all_trajectories = generate_all_trajectories(eqAssetsArray, N, K, Y)

# Print the shape of the results to verify
print(all_trajectories.shape)  # Should be (Y, M, N)
```

This approach ensures that the computation of trajectories is distributed across the available cores, with each core generating an equal portion of the total trajectories. This improves performance by leveraging parallel processing while keeping the structure of each trajectory generation intact.
