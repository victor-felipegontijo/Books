I understand your requirements better now. You want to generate a 2D array where each row corresponds to a different equity asset and each column represents a price increment.

Let’s revise the function and address the specific requirements:

	•	The output should be a 2D array of size  M \times N , where  M = \text{len(initial\_prices)} .
	•	Each row should represent an equity asset.
	•	Each column should represent a price increment.

Given this, let’s rework the code:

Revised Code

import numpy as np
import multiprocessing as mp

# Example definition of the EquityAsset class
class EquityAsset:
    def __init__(self, name, initial_price):
        self.name = name
        self.initial_price = initial_price

    def __repr__(self):
        return f"EquityAsset({self.name}, {self.initial_price})"

# Vectorized single_asset_trajectory function with random integer increments
def single_asset_trajectory_vectorized(initial_prices, N, K):
    # Generate random integer increments for all initial prices
    increments = np.random.randint(0, K, (len(initial_prices), N))
    trajectories = np.cumsum(increments, axis=1)  # Cumulative sum to simulate price paths
    trajectories += initial_prices[:, np.newaxis]  # Add initial prices to each trajectory
    return trajectories

# Function to parallelize the generation of trajectories for an array of EquityAsset objects
def generate_all_trajectories(eqAssetsArray, N, K):
    initial_prices = np.array([eqAsset.initial_price for eqAsset in eqAssetsArray])
    with mp.Pool(mp.cpu_count()) as pool:
        # Split initial prices into chunks for parallel processing
        chunks = np.array_split(initial_prices, mp.cpu_count())
        results = pool.starmap(single_asset_trajectory_vectorized, [(chunk, N, K) for chunk in chunks])
    
    # Concatenate results from all processes
    return np.concatenate(results, axis=0)

# Example usage
if __name__ == "__main__":
    # Create an array of EquityAsset objects
    eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

    # Number of price increments to generate for each EquityAsset
    N = 10
    
    # Maximum random increment
    K = 5

    # Generate trajectories
    all_trajectories = generate_all_trajectories(eqAssetsArray, N, K)

    # Print the results
    for i, eqAsset in enumerate(eqAssetsArray):
        print(f"Trajectories for {eqAsset.name}:")
        print(all_trajectories[i])

Explanation

	1.	Generating Random Increments:

increments = np.random.randint(0, K, (len(initial_prices), N))

	1.		•	np.random.randint(0, K, (len(initial_prices), N)) generates a 2D array of random integers between 0 and  K . The shape of the array is  M \times N , where  M  is the number of equity assets (len(initial_prices)) and  N  is the number of price increments.
	2.	Cumulative Sum to Simulate Price Paths:

trajectories = np.cumsum(increments, axis=1)

	2.		•	np.cumsum(increments, axis=1) computes the cumulative sum along each row, simulating the price path for each asset over  N  time steps.
	3.	Adding Initial Prices:

trajectories += initial_prices[:, np.newaxis]

	3.		•	initial_prices[:, np.newaxis] reshapes initial_prices to a column vector, which is then broadcast and added to each row of trajectories. This ensures that each trajectory starts from the respective initial price.
	4.	Parallel Processing:
	•	The initial prices are split into chunks for parallel processing.
	•	multiprocessing.Pool is used to parallelize the computation of trajectories.
	•	pool.starmap applies the vectorized function to each chunk of initial prices along with  N  and  K .
	•	The results from all processes are concatenated along the rows to form the final array of trajectories.

Usage Example

# Create an array of EquityAsset objects
eqAssetsArray = np.array([EquityAsset("Asset1", 100), EquityAsset("Asset2", 150), EquityAsset("Asset3", 200)])

# Number of price increments to generate for each EquityAsset
N = 10

# Maximum random increment
K = 5

# Generate trajectories
all_trajectories = generate_all_trajectories(eqAssetsArray, N, K)

# Print the results
for i, eqAsset in enumerate(eqAssetsArray):
    print(f"Trajectories for {eqAsset.name}:")
    print(all_trajectories[i])

This revised code correctly generates a 2D array where each row corresponds to a different equity asset and each column represents a price increment. The first coordinate represents the index of the equity asset, and the second coordinate represents the index of the price increment.
