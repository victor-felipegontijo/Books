import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

def getValuesAnalytics(Values, QuantileLevels, QuantileValues):
    """
    Displays a histogram with dynamic bin widths based on KDE, annotated quantiles, 
    density markers, and floating quantile labels below the x-axis.

    Args:
        Values (list or array): Empirical observations of a random variable.
        QuantileLevels (list or array): Quantile levels (e.g., [0.3, 0.5, 0.9]).
        QuantileValues (list or array): Quantile values corresponding to the levels.
    """
    # Convert input data to numpy array
    Values = np.array(Values)
    QuantileLevels = np.array(QuantileLevels)
    QuantileValues = np.array(QuantileValues)

    # Estimate the density using Gaussian KDE
    kde = gaussian_kde(Values)
    density = kde(Values)  # Get density estimates for each point

    # Sort the values and density estimates together
    sorted_indices = np.argsort(Values)
    sorted_values = Values[sorted_indices]
    sorted_density = density[sorted_indices]

    # Define dynamic bins based on KDE density
    density_thresholds = np.linspace(sorted_density.min(), sorted_density.max(), 20)
    bin_edges = [sorted_values[0]]  # Start with the minimum value
    for threshold in density_thresholds[1:]:
        # Add an edge at the last point below the current density threshold
        bin_edges.append(sorted_values[sorted_density <= threshold][-1])
    bin_edges = np.unique(bin_edges)  # Ensure no duplicate edges

    # Create histogram with dynamic bins
    hist, bin_edges = np.histogram(Values, bins=bin_edges)
    proportions = hist / len(Values)  # Normalize by total occurrences
    bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2

    # Plot the histogram
    plt.figure(figsize=(12, 6))
    plt.bar(bin_centers, proportions, width=np.diff(bin_edges), alpha=0.7,
            color="blue", edgecolor="black", align="center", label="Proportions")

    # Display proportions above each bar
    for center, prop in zip(bin_centers, proportions):
        plt.text(center, prop + 0.005, f"{prop:.2%}", color="blue", fontsize=9, ha="center")

    # Add red marks (x) at the x-axis for each occurrence
    plt.scatter(Values, np.zeros_like(Values), color="red", marker="x", label="Occurrences at X-axis", alpha=0.8)

    # Add quantile annotations
    height_increment = 0.05  # Increment for vertical placement
    current_height = max(proportions) * 0.9  # Start at 90% of max height

    for i, (level, value) in enumerate(zip(QuantileLevels, QuantileValues)):
        # Plot vertical lines
        plt.axvline(value, color="red", linestyle="--", linewidth=2)
        # Annotate quantile level with increasing heights
        plt.text(value, current_height, f"{level:.1%}", color="red", fontsize=10, ha="center", va="bottom")
        current_height -= height_increment  # Avoid overlap

    # Add floating quantile values below the x-axis
    for quantile_value in QuantileValues:
        plt.text(quantile_value, -0.02, f"{quantile_value}", color="red", fontsize=9,
                 ha="center", va="top", rotation=45, transform=plt.gca().transData)

    # Add labels, legend, and grid
    plt.title("Histogram with KDE-Based Dynamic Bins, Proportions, and Quantiles", fontsize=16)
    plt.xlabel("Value", fontsize=14)
    plt.ylabel("Proportion", fontsize=14)
    plt.legend(fontsize=12)
    plt.grid(alpha=0.3)

    # Adjust plot limits to make space for floating labels
    plt.gca().set_ylim(bottom=-0.05)

    # Show plot
    plt.tight_layout()
    plt.show()